[1mdiff --git a/api/test/data/usecases/add-account-usecase.spec.ts b/api/test/data/usecases/add-account-usecase.spec.ts[m
[1mindex c5f9bc9..eabeeff 100644[m
[1m--- a/api/test/data/usecases/add-account-usecase.spec.ts[m
[1m+++ b/api/test/data/usecases/add-account-usecase.spec.ts[m
[36m@@ -1,25 +1,28 @@[m
[32m+[m[32mimport { Hasher } from '../../../src/data/protocols/cryptography/hasher'[m
[32m+[m[32mimport { HashComparer } from '../../../src/data/protocols/cryptography/hasher-comparer'[m
 import { AddAccountRepositoy } from '../../../src/data/protocols/repository/add-account-repository'[m
[32m+[m[32mimport { LoadAccountByEmailRepository } from '../../../src/data/protocols/repository/load-account-by-email-repository'[m
 import { AddAccountUseCase } from '../../../src/data/usecases/add-account-usecase'[m
 import { AccountDto } from '../../../src/domain/dto/account-dto'[m
 import { Account } from '../../../src/domain/models/account'[m
 import { BCrypter } from '../../../src/infra/criptography/bcrypter'[m
 [m
[31m-// const buildAddAccountUseCaseStub = (): AddAccountUseCase => {[m
[31m-//   class AddAccountUseCaseStub implements AddAccountUseCase {[m
[31m-//     async add (dto: AccountDto): Promise<Account> {[m
[31m-//       const account: Account = {[m
[31m-//         id: 'any_id',[m
[31m-//         name: 'any_name',[m
[31m-//         email: 'any_email',[m
[31m-//         password: 'any_password'[m
[31m-//       }[m
[31m-//       return await new Promise(resolve => resolve(account))[m
[31m-//     }[m
[31m-//   }[m
[31m-//   return new AddAccountUseCaseStub()[m
[31m-// }[m
[31m-[m
[31m-const buildAddAccountRepositoryStub = (): AddAccountRepositoy => {[m
[32m+[m[32minterface SutTypes {[m
[32m+[m[32m  sut: AddAccountUseCase[m
[32m+[m[32m  addAccountRepositoryStub: AddAccountRepositoy[m
[32m+[m[32m  loadAccountRepositoryStub: LoadAccountByEmailRepository[m
[32m+[m[32m  hasherStub: Hasher[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst makeFakeDto = (): AccountDto => {[m
[32m+[m[32m  return {[m
[32m+[m[32m    name: 'any_name',[m
[32m+[m[32m    email: 'any_email',[m
[32m+[m[32m    password: 'any_password'[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst makeAddAccountRepositoryStub = (): AddAccountRepositoy => {[m
   class AddAccountRepositoryStub implements AddAccountRepositoy {[m
     async add (dto: AccountDto): Promise<Account> {[m
       const account: Account = {[m
[36m@@ -34,19 +37,60 @@[m [mconst buildAddAccountRepositoryStub = (): AddAccountRepositoy => {[m
   return new AddAccountRepositoryStub()[m
 }[m
 [m
[32m+[m[32mconst makeLoadAccountRepositoryStub = (): LoadAccountByEmailRepository => {[m
[32m+[m[32m  class LoadAccountRepositoryStub implements LoadAccountByEmailRepository {[m
[32m+[m[32m    async loadByEmail (email: string): Promise<Account | null> {[m
[32m+[m[32m      // return {[m
[32m+[m[32m      //   id: 'any_id',[m
[32m+[m[32m      //   name: 'any_name',[m
[32m+[m[32m      //   email: 'any_email',[m
[32m+[m[32m      //   password: 'any_password'[m
[32m+[m[32m      // }[m
[32m+[m[32m      return await new Promise(resolve => resolve(null))[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  return new LoadAccountRepositoryStub()[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst makeSut = (): SutTypes => {[m
[32m+[m[32m  const salt = 12[m
[32m+[m[32m  const hasherStub = new BCrypter(salt)[m
[32m+[m[32m  const addAccountRepositoryStub = makeAddAccountRepositoryStub()[m
[32m+[m[32m  const loadAccountRepositoryStub = makeLoadAccountRepositoryStub()[m
[32m+[m[32m  const sut = new AddAccountUseCase(hasherStub, addAccountRepositoryStub, loadAccountRepositoryStub)[m
[32m+[m[32m  return {[m
[32m+[m[32m    sut,[m
[32m+[m[32m    addAccountRepositoryStub,[m
[32m+[m[32m    loadAccountRepositoryStub,[m
[32m+[m[32m    hasherStub[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
 describe('AddAccountUseCase', () => {[m
   test('deve chamar o Hasher com o valor correto', async () => {[m
[31m-    const accountDto: AccountDto = {[m
[32m+[m[32m    const { sut, hasherStub } = makeSut()[m
[32m+[m[32m    const hasherSpy = jest.spyOn(hasherStub, 'hash')[m
[32m+[m[32m    await sut.add(makeFakeDto())[m
[32m+[m[32m    expect(hasherSpy).toHaveBeenCalledWith('any_password')[m
[32m+[m[32m  })[m
[32m+[m
[32m+[m[32m  test('deve chamar o LoadAccountEmailRepository com o valor correto', async () => {[m
[32m+[m[32m    const { sut, loadAccountRepositoryStub } = makeSut()[m
[32m+[m[32m    const loadEmailSpy = jest.spyOn(loadAccountRepositoryStub, 'loadByEmail')[m
[32m+[m[32m    await sut.add(makeFakeDto())[m
[32m+[m[32m    expect(loadEmailSpy).toHaveBeenCalledWith('any_email')[m
[32m+[m[32m  })[m
[32m+[m
[32m+[m[32m  test('deve retornar null ao cadastrar uma conta com email existente', async () => {[m
[32m+[m[32m    const accountModel = {[m
[32m+[m[32m      id: 'any_id',[m
       name: 'any_name',[m
       email: 'any_email',[m
       password: 'any_password'[m
     }[m
[31m-    const salt = 12[m
[31m-    const hasherPassword = new BCrypter(salt)[m
[31m-    const accountRepository = buildAddAccountRepositoryStub()[m
[31m-    const sut = new AddAccountUseCase(hasherPassword, accountRepository)[m
[31m-    const hasherSpy = jest.spyOn(hasherPassword, 'hash')[m
[31m-    await sut.add(accountDto)[m
[31m-    expect(hasherSpy).toHaveBeenCalledWith('any_password')[m
[32m+[m[32m    const { sut, loadAccountRepositoryStub } = makeSut()[m
[32m+[m[32m    jest.spyOn(loadAccountRepositoryStub, 'loadByEmail').mockReturnValueOnce(new Promise(resolve => resolve(accountModel)))[m
[32m+[m[32m    const account = await sut.add(makeFakeDto())[m
[32m+[m[32m    expect(account).toBeNull()[m
   })[m
 })[m
